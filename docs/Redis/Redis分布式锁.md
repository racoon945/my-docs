作者：Theseus
链接：https://zhuanlan.zhihu.com/p/93947224
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 前言

Redis是被广泛使用的数据存储服务, 可以用来实现缓存, 任务队列等等通用功能. 

Redis的SETNX命令, 可以检查key是否存在, 在key不存在时创建这个key-value对, 在key已经存在的情况下放弃执行, 看起来非常适合用来实现“锁”这类机制. 实际上, 基于SETNX的锁被大量使用.

这样真的适合吗? 如此简单就可以实现锁的话, 为什么还有基于ZK, etcd的“复杂”分布式锁实现?

## 为什么使用锁

[锁](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Lock_(computer_science))限制独立的进程同时占用同一资源, 资源可以是数据库记录, (行级锁对应一条记录, 表级锁对应一类记录...), 可以是文件系统的文件 (想象两个人同时强行vi一份文件), 可以是计算资源如cpu/内存, 等等. 实际上, 我们通常是出于两种目的, 希望进行这种限制:

1. 安全性(safety) 通过锁的限制, 对资源的并发操作被解除了, 不同的进程只能顺序操作资源. 非常实际的例子是数据库事务
2. 效率(effectiveness) 锁限制不同的进程挤占计算资源. 例如两个请求同时请求计算一个大数是否是质数, 合理的设计应当只进行一次计算, 然后将结果返回给两个请求, 而不是独立计算两次

## Redis单机锁的优点和缺陷

提到单机, 读者必然会联想到有限的可靠性 (availability). 既然不可靠, 那多半也不安全

首先, 明确一下安全性的定义:

```text
安全性: 互斥. 任一时刻, 锁只能有0个或1个持有者
```

redis锁的实现可以多种多样, 我选取一个常用的实现, 伪代码如下

```text
def 获取自动超时锁(名称, timeout):
   identifier = 唯一字符串
   start = time.now()
   while (time.now() - start < 10000):
      if redis.SET(名称 identifier NX EX timeout) //NX使得SET具备SETNX的效果, EX设置ttl
         return identifier
      else
         time.sleep(0.1)
      return False
```

看起来非常完美, 如果SETNX成功, 就获取到锁, 如果不成功, 10秒内不断重试

使用这个方法:

```text
def working
lock = 获取自动超时锁 (资源名称, 30秒)
try
  操作资源
1:  if lock.notExpired // 判断锁是否有效
2:  提交资源修改

finally
  释放 lock (redis DEL)
```

似乎也不错, 然而这里有一个重大问题, 使用这个锁的客户端, 如何判断锁没有超时呢?

客户端显然不存在与redis服务器中, 那么只能依靠redis的TTL命令来查询锁的剩余时间, 然后根据这个剩余时间来判断锁是否超时

然而在通常的计算机系统中, 很难获取到一个可靠的时间. 系统可能因于时间服务器同步调整时间, 虚拟机可能调整时间, JVM GC可能导致时间停顿( 除非你使用了类似Google Spanner的硬件系统, 用铯原子钟做你的时间硬件 :) ), 线程调度可能导致两行相邻代码的执行有时间间隔. 也就是说, 上述伪代码的**1:行lock.notExpired**这个客户端执行的判断可能无效, 即便有效, 在1:和2:两行之间, 也可能经过一个不可知的停顿, 让1:的判断不再有效. 这样, 在你提交资源修改时, 可能有另一个进程, 也获取了这个锁, 正在提交

由此, 我们可以看出单机redis锁是不安全的, 当然, 这种不安全性的来源是分布式系统的内在特性--异步性.

```text
make no mistake, a system consists of a redis client and a redis server is a distributed system 
```

然而, 这样一个锁的实现仍然是很有用处的, 只要你的使用场景不那么在意安全性. 例如我们提到的计算大质数. 哪怕在比较极端的情况下, 这个锁失效了, 损失也不过是重复了这次计算

而这个实现是如此简单, 又重复利用了你已经使用在系统中的redis服务, 从工程角度看, 使用这个锁再合适不过

简单总结一下, 单机redis锁:

```text
pros:
1. 简单
2. 利用已有的redis服务
3. 只有在比较极端的情况下才会出错
cons:
1. 不是绝对安全, 不要在需要绝对安全的数据操作上依赖这类锁
```

## RedLock

为了提高可靠性, 同时提供安全性, 

[Distributed locks with Redisredis.io](https://link.zhihu.com/?target=https%3A//redis.io/topics/distlock)

这个算法使用多个独立的redis服务器(如5个), 包括以下5步

```text
1. 客户端获取当前时间, 生成一个随机值作为锁的值
2. 依次尝试在所有5个redis上取得同一个锁 (使用类似单机redis锁的方法, 使用同样的key和同一个随机值)
   获取锁的操作本身需要设定一个比较小的超时时间 (如5-50ms), 防止在一个挂掉的redis上浪费太多时间
   如果一个redis不可用, 要尽快开始尝试下一个
3. 客户端计算获取锁一共用了多长时间, 通过用当前时间减去第1步得到的时间
   如果客户端获取了多数redis上的这个锁 (3 of 5), 并且这时还没有超过锁的超时时间, 
   这个锁就算是获取成功了
4. 如果锁获取成功了, 有效时间就按 锁超时时间-获取锁花费时间 算
5. 如果获取锁🔒失败, 尝试在所有redis上解除锁
   (解除锁的操作是一段lua script, 删除一个key如果key的value是第1步生成的随机值)
```

这个算法看起来正常, 引入了quarum(法定人数)的概念, 使用多个redis主机, 而且比raft这样的协议简单多了. 它是一个符合爱因斯坦理念, **As simple as possible, but not simpler** 的算法吗?

很不幸, 我们对单机redis安全性的分析在这里完全适用. 客户端无法完全确定自己能计算时间差, 除非使用了特殊硬件

也就是说, redlock不但无法解决我们上面提到的1:和2:之间锁状态不确定的问题

```text
1:  if lock.notExpired // 判断锁是否有效
2:  提交资源修改  finally   释放 lock (redis DEL)
```

还在它的3. 4.步引入了同样的问题

我们再看一看redlock对可靠性的提升

单机版redis锁实际上可以非常简单的提升可靠性, 即使用异步复制的主从结构

既然我们已经讨论过, 单机版redis锁相当适合不在意安全性的情况, 那么异步复制导致的数据丢失的可能性也就可以忽略不计了

在有这种简单方案的情况下, 还需要使用3个/5个或更多节点的复杂结构来提高可靠性吗?

## 安全可靠的分布式锁的实现

使用consensus(共识)算法来实现分布式锁是在保证安全性优先的同时, 提供可靠性/性能保证的方法

可以使用的服务包括(不限于): chubby, zookeeper, etcd, consul

如果你真的需要在数据敏感的服务中使用分布式锁, 请优先考虑这些方式

但是, 需要注意的是, 即使使用consensus算法来获取锁是安全的, 

```text
1:  if lock.notExpired // 判断锁是否有效 
2:  提交资源修改  finally   释放 lock (redis DEL)
```

这两步总是在应用层面 (锁的客户端) 执行, 仍然不能保证绝对安全.

幸运的是, 有一个简单的应对方案: fencing token

在每一次获取锁时, 提供锁的服务发布一个token, 并保证后发的token永远大于先发的token. 对于consensus算法实现的服务来说, 这是非常容易的

如果你的资源服务支持类似compare&swap (CAS操作, 比较提交过来的值和当前值, 如果满足一定条件, 就接受这个提交, 如不满足, 则拒绝这次提交) 的方式来提交修改, 这个token就可以作为fencing token一并提交给资源服务. 这样, 如果在1:和2:之间, 锁过期, 有另一个服务获取了锁并完成提交, 2:的提交就会失败

## 总结

redlock或redis recipes推荐的锁的实现, 都不是绝对安全的.

如果你需要处理敏感数据, 不要依赖它们来保证数据可靠.

但是, redis锁只会在比较极端的情况下出错, 所以如果你处在一个仅仅需要保证数据**大部分时候可靠, 万一有问题也无所谓**的情况下, 那么放心的使用单节点redis或主从集群来加锁吧. 至于redlock, 如果你不在乎需要多维护几个独立的redis服务, 那么它可能比单节点redis出错的概率稍低, 仅此而已